Build Flow. Managing a pipeline in Jenkins requires moderate configurations across all the jobs participating in the flow. Configurations can combine different types, including parameterized build, parallel builds, joins or downstream wait. With the addition of more jobs, it gets quite complicated for further updates. The build process is then scattered across all of those jobs and is very complex to maintain. Individual jobs are meant to carry the responsibility for their unique task, but with this pipeline configuration they also carry connection details which pollute their goal. In this scenario, Build Flow Pipeline comes to the rescue. This plugin is designed to handle complex build workflows (aka build pipelines) as a dedicated entity in Jenkins. Build Flow enables you to define an upper level Flow item to manage job orchestration and link up rules, using a dedicated DSL. This DSL makes the flow definition very concise and readable. Main jobs don’t know anything about the pipeline as everything is externalized to the flow. 
The only thing missing with this plugin is it doesn't have much support for graphical visualization on monitors. There is a Build Graph View Plugin but it wasn’t intended for this use. If graph view doesn't matter to you, then this can be the best plugin to try out. Otherwise go with regular scattered configuration.
Build Monitor. Visibility is the core aspect of the Jenkins CI tool. It being understood that CI is a part of collective ownership, everyone should know that if something breaks, some part of it is not working consistently. To make this a reality, having that projected in a monitor visible to all is a welcome move. Build Monitor Plugin provides a highly visible view of the status of selected Jenkins jobs. It easily accommodates different computer screen sizes and is ideal as an Extreme Feedback Device to be displayed on a screen on your office wall. 
Build Name Setter. Every build comes with a build number, but most of the time its hard to identify a particular build with a build number. Many types of builds get executed with an update from revision number by source code, so it would be great deal easier to use revision number as a unique identifier. In  order to visualize the actual revision numbers within Jenkins, the Build Name Setter Plugin can be used instead. This makes it easier to identify builds by revision number instead of by build number.
Build Pipeline. As stated earlier, visibility is the core aspect of Jenkins pipeline to be successful in terms of its value.This plugin helps renders upstream and downstream connected jobs that typically form a build pipeline in a very nice fashion on the monitor, big monitors especially. It also offers the ability to define manual triggers for jobs that require intervention prior to execution, e.g. an approval process outside of Jenkins. This would help other decision making teams(Non Developers like QA, BA or other kind of authority) to continue the pipeline.
Build Timeout. Build-timeout is simple, but necessary.
Clone Workspace SCM. This plugin makes it possible to archive the workspace from builds of one project and reuse them as the SCM source for another project. This is useful in terms of avoiding space issues, and avoiding copying over the same source code which is not absolutely needed in a couple of cases, resulting in faster execution and feedback.
Cobertura. This plugin integrates Cobertura coverage reports to Jenkins. If testing framework in your build job creates reports aligned to xUnit standards, this can be a handy plugin to project the progress in nice charts and detailed format.
Cucumber Test Result. This plugin allows you to show the results of Cucumber tests within Jenkins.This plugin really helped the team to accommodate the BDD development style. Cucumber plugin formats the raw reports into very nice and visible charts, which can be easily understood by Non Tech folks like BA and Product owners.
Delivery Pipeline. This plugin visualizes Delivery Pipelines (Jobs with upstream/downstream dependencies). This is somewhat similar to Build pipeline plugin but has avery lean design. This is the favorite plugin across the teams here in my company.
Email Extension. This plugin is a replacement for Jenkins's email publisher. This is more advanced plugin with better features for sending build status messages. Please make sure you set up very granular and effective means of communication to the relevant team members, rather than whole team.
Git. This plugin integrates GIT with Jenkins. This plugin also adds the feature of notifying the build about git code base updates using REST API. This is a very useful feature where Git Hooks can notify the builds immediately, rather than the build waiting for the Git poll interval.
Heavy Job. During concurrent execution of jobs, Heavy Job Plugin can be used to allocate all available executors on that node in order to ensure exclusive access to all the local repositories.
HipChat. This plugin is a HipChat notifier that can publish build status to HipChat rooms. This plugin add more visibility and awareness in terms of build status for the team, resulting in a better sense of collective ownership.
JaCoCo. This plugin allows you to capture code coverage report from JaCoCo. Jenkins will generate the trend report of coverage. This plugin is the fork of the [Emma Plugin]. A big part of the code structure comes from it, however, it is completely refactored. It also includes functionality similar to the [Emma Coverage Column] which allows you to include a column in Dashboards which displays the latest overall coverage numbers and links to the coverage report.
Join. If you are thinking of setting up parallel jobs in pipeline, you may end up in a scenario known commonly as  'diamond' shape project dependency. It means there is a single parent job that should start several downstream jobs. Once those jobs are finished, a single aggregation job runs. This plugin allows a job to be run after all the immediate downstream jobs have completed. In this way,  the execution can branch out and perform many steps in parallel, and then run a final aggregation step just once after all the parallel work is finished. More complex interactions are not possible with this plugin.
NodeLabel Parameter. NodeLabel Parameter Plugin can be used to assign the cleanup jobs to the specific nodes. This plugin adds two new parameter types to job configuration - node and label. This allows it to dynamically select the node where a job/project should be executed.
Parameterized Trigger. This plugin lets you trigger new builds when your build has completed, with various ways of specifying parameters for the new build. You can add multiple configurations: each has a list of projects to trigger, a condition for when to trigger them (based on the result of the current build), and a parameters section.
Performance. This is very handy plugin in terms of Performance testing. This plugin integrates JMeter reports, JUnit reports, work output, and Iarge reports into Hudson.
Priority Sorter. In scenarios where multiple pipelines execute in parallel,  build steps of different pipelines are often expected not to get executed in a random order. For example, deploying artifacts of a pipeline to a live server cannot be succeeded by deploying artifacts of another pipeline earlier than a smoke test has run for the already deployed artifacts. This can be guaranteed by assigning a higher priority to the smoke test job using the Priority Sorter Plugin.
Rebuilder Plugin. Sometimes a step in the pipeline might fail because of some technical error that is not related to the associated revision like Jenkins restart, or a memory issue. In order to trigger a rebuild of the failed downstream job the pipeline parameters revision number and build number need to be specified manually, which is a bit awkward. Here the Rebuilder Plugin comes in handy. It facilitates rebuilding a job with the same parameters as the failed build.
Shared Workspace. This plugin allows you to share workspaces for Jenkins jobs with the same SCM repos. It saves some disk space and repetitive steps, if you have different jobs with identical repos. The importance of this plugin is not well understood by the developers, considering memory is cheap. But following standard practices and promoting reusability can be fruitful in the future.
SSH Agent. This plugin allows you to provide SSH credentials to builds via a ssh agent in Jenkins.
SSH. You can use the SSH Plugin to run shell commands on a remote machine via ssh.
SSH Slaves. This plugin allows you to manage slaves running on Unix machines over SSH. It adds a new type of slave launch method. This launch method will open a SSH connection to the specified host as the specified username. Once it has a suitable version of java, it copies the latest slave.jar via SFTP. It starts the slave process.
Subversion.This plugin adds the Subversion support (via SVNKit) to Jenkins.
Thinbackup. This plugin simply backs up the global and job specific configurations (not the archive or the workspace). One of the main feature is automated backups. This is far better then Backup Plugin.
Throttle Concurrent Builds. The Throttle Concurrent Builds Plugin can be used to define throttle categories and restrict concurrent execution of jobs by assigning them to the same throttle category.
Wall Display. A wall display that shows job build progress in a way suitable for public wall displays. Rendering is performed using ajax based on REST API calls, so it requires no page refreshes.
Workspace Cleanup. One of the common recommended task of Jenkin Job is to cleanup itself after build is finished to maintain immunity for next build. I have often seen teams use  ‘rm-rf*’ in script which works fine, but doesn't cover bad scenarios. This plugin is meant to save us from this granular job. This plugin deletes the project workspace after a build is finished.
xUnit. This plugin makes it possible to record xUnit test reports.
